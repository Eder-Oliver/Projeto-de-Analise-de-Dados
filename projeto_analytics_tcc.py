# -*- coding: utf-8 -*-
"""PROJETO_ANALYTICS_TCC.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/190SML-RclGau4jRHdR1ZsupszWlX8iMC

####O objetivo geral deste trabalho é, identificar tendências e padrões por meio da segmentação e classificação dos municípios do estado de Minas Gerais, com base nos indicadores como: População total, Mortalidade infantil, Expectativa de vida, Renda per capta, IDHM, IDHM Educação, Expectativa de anos de estudo, Índice de Gini.

Em especial, busca-se estimar: a qualidade de vida da população em relação a renda, educação, expectativa de vida e municípios com maior renda per capita.

A expectativa de vida está diretamente ligada às condições sociais, como educação e renda.

Por sua vez, a renda per capita, é um fator determinante para o desenvolvimento dos municípios e a população local, é um dos pilares do IDHM “Índice de desenvolvimento humano municipal”, juntamente com a Educação, que compõe IDHM Educacional, e ambos são diretamente proporcionais à uma melhor qualidade de vida para população.

Fonte de obtenção da base de dados:
https://www.ipea.gov.br/ipeageo/bases.html
https://www.ipea.gov.br/ipeageo/arquivos/bases/MG_Mun97_region.xls

#Bibliotecas a serem utilizadas
"""

#Importando bibliotecas
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import statsmodels.api as sm
import statsmodels.formula.api as smf
import plotly.figure_factory as pff
from sklearn.cluster import KMeans
import tensorflow as tf
from tensorflow import keras
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.metrics import classification_report
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
from tensorflow.keras.utils import to_categorical
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.model_selection import train_test_split
!pip install pycaret
from pycaret.classification import*

"""#Carregando os dados"""

df = pd.read_excel('/content/drive/MyDrive/FIA LABDATA/ANALYTICS/Dataset/TCC/IDH MG 2010.xlsx')

df.head()

df.sample(10)

df.columns

df.info()

"""#Verificando o tamanho do DataFrame"""

df.shape

df.dtypes

"""#Renomeando as colunas que serão utilizadas para análise"""

df = df.rename(columns={'Nome da Unidade da Federação' : 'Estado',
                        'Esperança de vida ao nascer' : 'Expectativa_de_vida',
                        'Mortalidade infantil' : 'Mortalidade_infantil',
                        'IDHM Renda' : 'Renda',
                        'IDHM Educação' : 'IDHM_Educacao',
                        'População total' : 'Populacao_total',
                        'População residente feminina' : 'Populacao_resid_fem',
                        'População residente masculina' : 'Populacao_resid_masc',
                        'Renda per capita' : 'Renda_per_capita',
                        'Índice de Gini' : 'Indice_Gini',
                        'Expectativa de anos de estudo' : 'Expectativa_anos_estudo'
                        })

"""#Definindo DataFrame Atual"""

df1 = df[['Estado',
               'Município',
               'Mortalidade_infantil',
               'Expectativa_de_vida',
               'Expectativa_anos_estudo',
               'IDHM',
               'IDHM_Educacao',
               'Populacao_total',
               'Renda_per_capita',
               'Indice_Gini']]

"""#Carregando DataFrame Atual"""

df1

df1.describe() #Descrição do DataFrame utilizado para análise

df1.describe().transpose()

df1_numeric = df1.select_dtypes(include='number')
df1['Estado'] = df1['Estado'].astype('category')
df1['Município'] = df1['Município'].astype('category')

"""#Correlacionando as informações do df_atual"""

df1_numeric.corr(method='pearson') #Correlação entre as colunas do DataFrame

# Análise Exploratória
correlaçao = df1_numeric.corr(method='pearson') # Calculate and store correlation

plt.figure(figsize=(10,8))
sns.heatmap(correlaçao, annot=True, cbar=True, square=True, fmt=".2f", cmap=('PuBu'))
plt.title('Mapa de Correlação')
plt.show()

"""####Correlações Fortes e Positivas:

IDHM e seus componentes: O IDHM apresenta correlações fortes e positivas com seus componentes: IDHM_Educacao (0.93), Renda_per_capita (0.88) e Expectativa_de_vida (0.79). Isso indica que melhorias em educação, renda e expectativa de vida estão diretamente ligadas a um IDHM mais alto.
Expectativa de vida e Renda per capita: A correlação de 0.75 sugere que locais com maior renda per capita tendem a ter uma população com maior expectativa de vida.
IDHM e Renda per capita: A correlação de 0.88 indica uma forte relação entre o desenvolvimento humano e a renda da população.
IDHM_Educacao e IDHM: A correlação de 0.93 demonstra que o componente educação tem um peso significativo no cálculo do IDHM.

Correlações Fortes e Negativas:

Mortalidade Infantil e Expectativa de vida: A correlação de -1.00 indica uma relação inversa perfeita. Onde a mortalidade infantil é alta, a expectativa de vida tende a ser baixa e vice-versa.
Mortalidade Infantil e IDHM: A correlação de -0.79 sugere que locais com alta mortalidade infantil tendem a ter um IDHM mais baixo.
Mortalidade Infantil e Renda per capita: A correlação de -0.73 indica que a mortalidade infantil tende a ser menor em locais com maior renda per capita.


População Total: Apresenta correlações fracas com as demais variáveis, indicando que o tamanho da população não tem um impacto determinante nos outros indicadores.
Índice Gini: O Índice Gini, que mede a desigualdade de renda, apresenta correlações muito baixas com as outras variáveis. Isso sugere que a desigualdade de renda não está fortemente associada aos outros indicadores sociais e econômicos neste conjunto de dados.
Em resumo: O gráfico revela que o desenvolvimento humano (IDHM) está intimamente ligado à educação, renda e expectativa de vida. A mortalidade infantil é um fator que impacta negativamente o IDHM e está associada a baixos níveis de renda e expectativa de vida.

#Média da renda per capita relacionada à expectativa de vida, educação e Indice de Gini
"""

top_15_municipios = df.sort_values(by='Município', ascending=False).head(15)

plt.figure(figsize=(10,5))
sns.barplot(data=top_15_municipios, y='Município', x='Expectativa_anos_estudo', hue='Município', palette=('PuBu'))
plt.xlabel('Expectativa_anos_estudo')
plt.ylabel('Município')
plt.title('Os 15 municípios com melhores médias de expectativa de anos estudo')
plt.xticks(rotation=0)
plt.show()

"""###O gráfico mostra os 15 municípios com as melhores médias de expectativa de anos de estudo, destacando a diferença na qualidade e na duração da educação oferecida em diferentes localidades."""

#Mapa de correlação
plt.figure(figsize=(12,8))

sns.pairplot(df1[['Município','Expectativa_anos_estudo', 'IDHM_Educacao', 'IDHM', 'Renda_per_capita' ]], hue='Expectativa_anos_estudo', palette=('PuBu'));
plt.suptitle('Análise de Relações entre Variáveis Socioeconômicas e Educacionais', fontsize=12, y=1.02)

plt.show()

"""#Expectativa de vida por Renda per Capita"""

plt.figure(figsize=(12,6))

sns.scatterplot(x='Renda_per_capita', y='Expectativa_de_vida', data=df1,
                hue='Renda_per_capita', palette='viridis', s=100, alpha=0.7)

plt.title('Relação entre Renda per Capita e Expectativa de Vida', fontsize=14)

plt.xlabel('Renda per Capita', fontsize=12)
plt.ylabel('Expectativa de Vida (anos)', fontsize=12)

plt.legend(title='Renda per Capita')

plt.tight_layout()
plt.show()

"""###O gráfico de dispersão apresentado ilustra a relação entre a Renda per Capita e a Expectativa de Vida (em anos). Cada ponto no gráfico representa um conjunto de dados que inclui a renda per capita e a expectativa de vida.

Principais Observações:
Correlação Positiva: Há uma clara tendência de correlação positiva, onde, à medida que a renda per capita aumenta, a expectativa de vida também tende a aumentar. Isso é indicado pela distribuição ascendente dos pontos.

Distribuição dos Dados:

A maioria dos pontos está concentrada entre a faixa de renda per capita de 200,00 a 900,00 Reais, com expectativa de vida variando entre 70 e 78 anos.
À medida que a renda per capita ultrapassa os R$1.200, há menos pontos, mas a expectativa de vida nesses casos também é maior.

O gráfico, portanto, sugere que, em geral, uma maior renda per capita está associada a uma maior expectativa de vida.

# Quinze maiores rendas per capita por município de Minas Gerais
"""

top_15_rendas = df.sort_values(by='Renda_per_capita', ascending=False).head(15)

plt.figure(figsize=(10,5))
sns.barplot(data=top_15_rendas, y='Município', x='Renda_per_capita', hue='Município',  palette=('PuBu'))
plt.xlabel('Renda per capita')
plt.ylabel('Município')
plt.title('15 maiores Rendas por Município')
plt.xticks(rotation=0)
plt.show()

"""###O gráfico representa as 15 maiores rendas per capita por município em Minas Gerais.
Nova Lima e Belo Horizonte se destacam entre os demais municípios listados, sendo que os outros municípios estão em um agrupamento com renda per capita entre 750,00 e 1000,00 Reais.

#População Minas Gerais 2010
"""

#Somando a população total de Minas Gerais.
df.Populacao_total.sum()

"""#Mapa informativo de Minas Gerais

#Instalação Biblioteca Folium. Fonte: https://pypi.org/project/folium/
#A bibliteca folium é baseada em Python, permitindo  a criação de mapas interativos, onde podemos  inserir diversas informações como (mapa de calor, marcações, quantidade populacional, dimensão territorial) para uma melhor visualização dos dados analisados e aplicados.
"""

#Instalando a biblioteca folium.
!pip install folium

#Impotando biblioteca folium
import folium

#Criando parâmetros Mapa Minas Gerais
Mapa_MG = folium.Map(
    location   = [-23.5 ,-40],
    tiles      = "OpenStreetmap" ,
    zoom_start = 6.2,
    )

#Plotando Mapa de Minas Gerais com a população do ano de 2010
 folium.Marker(
      [-19.912998, -43.940933], #Localização Geográfica MG (lat , lon)
      popup='<i>Belo Horizonte</i>',
      tooltip='População Total de Minas Gerais no ano de 2010 "19597330"',
      icon=folium.Icon(color='red')
      ).add_to(Mapa_MG)

Mapa_MG

"""#Arquivo para cálculo Densidade demografica.
#Fonte: https://www.ibge.gov.br/cidades-e-estados/mg/
"""

#Carregamento do arquivo
df2 = pd.read_excel('/content/drive/MyDrive/FIA LABDATA/ANALYTICS/Dataset/TCC/DENSIDADE DEMOGRAFICA.xlsx')
df2.head()

# Calcular a densidade demográfica (habitantes por km²)
df2['Densidade_Demografica'] = df2['Populacao_residente'] / df2['Área_Territorial']

# Criar a figura e os eixos
plt.figure(figsize=(10, 7))

# Plotar o gráfico de dispersão com Seaborn
sns.scatterplot(x='Densidade_Demografica', y='Populacao_residente', data=df2, alpha=0.7)
sns.regplot(x='Densidade_Demografica', y='Populacao_residente', data=df2, scatter=False, color='blue')

# Configurar títulos e rótulos dos eixos
plt.title('Relação entre Densidade Demográfica e População Residente em MG')
plt.xlabel('Densidade Demográfica (hab/km²)')
plt.ylabel('População Residente')

# Exibir a plotagem
plt.tight_layout()
plt.show()

"""#Dados para construção piramide etária da população de Minas Gerais no ano de  2010
#Fonte: https://sidra.ibge.gov.br/tabela/7358
"""

#Carregamento e leitura da tabela 7358, desconsiderando as 6 primeiras e a ultima linha.
df3 = pd.read_excel('/content/drive/MyDrive/FIA LABDATA/ANALYTICS/Dataset/TCC/tabela7358.xlsx', skiprows=6, skipfooter=1)
df3.head()

#Renomear colunas
df3.columns = ['Idade', 'Masculino', 'Feminino']
df3.head()

#Calculo para obtenção da população total (masculino e feminino)
df3.columns = ['Idade', 'M', 'F']
df3.loc['Total']= df3.sum()
#Nomeando a última linha de Total
df3.loc[df3.index[-1], 'Idade' ] = 'Total'
df3

#Total Geral
total_geral = df3.loc[df3.index[-1], 'F'] + df3.loc[df3.index[-1], 'M']
total_geral

#Remoção da  linha de Total
df3 = df3.drop('Total', axis=0)
df3

#Conversão dos  valores para  porcentagens do Total
df3['M'] = df3['M'] / total_geral * -100
df3['F'] = df3['F'] / total_geral * 100

df3

#Invertendo a ordem das idades
Idades = [
 '80 anos ou mais',
 '75 a 79 anos',
 '70 a 74 anos',
 '65 a 69 anos',
 '60 a 64 anos',
 '55 a 59 anos',
 '50 a 54 anos',
 '45 a 49 anos',
 '40 a 44 anos',
 '35 a 39 anos',
 '30 a 34 anos',
 '25 a 29 anos',
 '20 a 24 anos',
 '15 a 19 anos',
 '10 a 14 anos',
 '5 a 9 anos',
 '0 a 4 anos']

#Estrutura da Pirâmide Etária
fig, ax = plt.subplots(figsize=(10,8))

ax1 = sns.barplot(x='M', y='Idade', data=df3, order=Idades, color='blue')
ax2 = sns.barplot(x='F', y='Idade', data=df3, order=Idades, color='red')

plt.title('Pirâmide etária (%) Minas Gerais 2010')
plt.xlabel('Masculino/Feminino')

plt.xticks(ticks=[-4, -3, -2, -1, 0, 1, 2, 3, 4],
labels=['4', '3', '2', '1', '0', '1', '2', '3', '4']);


plt.tight_layout()
plt.show()

"""A pirâmide etária apresentada mostra a distribuição percentual da população de Minas Gerais em 2010, dividida por faixas etárias e por sexo (masculino e feminino).

A pirâmide tem uma base larga que vai se afunilando à medida que as faixas etárias aumentam, indicando uma maior concentração de população nas faixas etárias mais jovens e uma diminuição gradual conforme a idade avança.

Em geral, as proporções de homens e mulheres são bastante semelhantes na maioria das faixas etárias, mas observa-se uma ligeira predominância feminina nas faixas etárias mais avançadas (acima de 60 anos).
As faixas etárias de 0 a 4 anos até 20 a 24 anos são as mais representativas, mostrando que a população jovem era uma parcela significativa da população total em 2010.

A parte superior da pirâmide (faixas etárias a partir de 60 anos) é mais estreita, refletindo uma menor proporção de idosos na população, com uma leve maior participação feminina.

Essa pirâmide etária é característica de uma população em transição, com uma base jovem ainda ampla, mas já mostrando sinais de envelhecimento com uma população idosa crescente.

#Desenvolvendo Dendrograma para correlação do municípios com similaridade de renda per capita.
"""

#Filtrando as colunas que serão utilizadas
df_dendrograma2 = df1.filter(regex='Município|Renda_per_capita')

#Filtrando os 15 municípios com maior renda per capita
df_dendrograma2 = df_dendrograma2.sort_values(by='Renda_per_capita', ascending=False).head(15)

df_dendrograma2

#Criando indices
df_dendrograma2 = df_dendrograma2.set_index('Município')

df_dendrograma2.index

#Importando biblioteca
from scipy.cluster.hierarchy import dendrogram, linkage

#Criando Label 'Rótulo'
label_list = df_dendrograma2.index

label_list

#Plotando Dendrograma com os 15 municípios com maior renda per capita
plt.figure(figsize=(10,8))
# Controle a densidade do dendrograma
metodo_complete = linkage(df_dendrograma2, 'complete')
dendrogram(metodo_complete,
           labels=label_list,
           leaf_rotation=45,
           leaf_font_size=10,
           orientation='top',
           truncate_mode='lastp',
           p=30,
           show_contracted=True,
           above_threshold_color='blue'
           )

plt.title('Dendrograma Hierárquico (Método Complete)')
plt.xlabel('Índice das Observações')
plt.ylabel('Distância')
plt.tight_layout()

from scipy.cluster.hierarchy import fcluster

corte = 800
clusters = fcluster(metodo_complete, corte, criterion='distance')

clusters

#Adicionando uma coluna (cluster_id) ao df_dendrograma
df_dendrograma2['cluster_id']= clusters

#Apresentando o df com a coluna adicionada
df_dendrograma2.head(15)

#Filtrando os municípios relacionados aos clusters e apresentando as respectivas renda per capita
df_dendrograma2[df_dendrograma2['cluster_id']==1]

"""##Segmentando os clusters"""

sns.set_theme(style="whitegrid")
plt.figure(figsize=(10,8))

df_ordenado = df_dendrograma2.sort_values('Renda_per_capita', ascending=False)
ax = sns.barplot(x='cluster_id', y='Renda_per_capita', data=df_ordenado, palette='PuBu')

plt.xlabel('Cluster ID', fontsize=12)
plt.ylabel('Renda per Capita', fontsize=12)
plt.title('Renda per Capita por Cluster', fontsize=14)

for p in ax.patches:
    ax.annotate(f'{p.get_height():.2f}', (p.get_x() + p.get_width() / 2., p.get_height()),
                ha ='center', va ='center', xytext = (0, 10), textcoords = 'offset points')

plt.xticks(rotation=0)
plt.tight_layout();

# Seleção das features
X = df1[['Renda_per_capita', 'Expectativa_anos_estudo']]

# Normalização
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# Aplicação do K-means (k = 3, por exemplo)
kmeans = KMeans(n_clusters=3, random_state=42)
df1['cluster'] = kmeans.fit_predict(X_scaled)

# Visualização dos clusters
plt.figure(figsize=(10,6))
sns.scatterplot(x='Renda_per_capita', y='Expectativa_anos_estudo', hue='cluster', data=df1, palette='viridis')
plt.title('Clusters de Municípios')
plt.show()

"""##Criando ABT (ANALYTICS BASE TABLE), para treinamento de modelos de classificação."""

# Calcular os quartis do IDHM
quartis_idh = df1['IDHM'].quantile([0.25, 0.5, 0.75])

# Criar a coluna 'Categoria_IDH'
def categorizar_idh(idh):
  if idh <= quartis_idh[0.25]:
    return 'Baixo'
  elif idh <= quartis_idh[0.75]:
    return 'Médio'
  else:
    return 'Alto'

df1['Categoria_IDH'] = df1['IDHM'].apply(categorizar_idh)

# Codificar a coluna 'Municipio'
le = LabelEncoder()
df1['Municipio_encoded'] = le.fit_transform(df1['Município'])

# Criar o DataFrame 'abt'
abt = df1[['Município', 'Municipio_encoded', 'Renda_per_capita', 'Expectativa_anos_estudo', 'IDHM', 'Categoria_IDH']]

# Exibir as 5 primeiras linhas do DataFrame 'abt'
print(abt.head().to_markdown(index=False, numalign="left", stralign="left"))

abt

from matplotlib import pyplot as plt
abt['IDHM'].plot(kind='hist', bins=20, title='IDHM')
plt.gca().spines[['top', 'right',]].set_visible(False)

from matplotlib import pyplot as plt
import seaborn as sns
figsize = (12, 1.2 * len(abt['Categoria_IDH'].unique()))
plt.figure(figsize=figsize)
sns.violinplot(abt, x='IDHM', y='Categoria_IDH', inner='box', palette='Dark2')
sns.despine(top=True, right=True, bottom=True, left=True)

from matplotlib import pyplot as plt
import seaborn as sns
figsize = (12, 1.2 * len(abt['Categoria_IDH'].unique()))
plt.figure(figsize=figsize)
sns.violinplot(abt, x='Renda_per_capita', y='Categoria_IDH', inner='box', palette='Dark2')
sns.despine(top=True, right=True, bottom=True, left=True)

abt['Renda_per_capita'].plot(kind='hist', bins=20, title='Renda per capita')
plt.gca().spines[['top', 'right',]].set_visible(False)

abt.groupby('Categoria_IDH',).size().plot(kind='barh', color=sns.palettes.mpl_palette('Dark2'))
plt.gca().spines[['top', 'right',]].set_visible(False)

abt['Expectativa_anos_estudo'].plot(kind='hist', bins=20, title='Expectativa_anos_estudo')
plt.gca().spines[['top', 'right',]].set_visible(False)

"""##Criando modelo de classificação"""

# Variáveis preditoras (características que serão usadas para fazer a previsão)
X = abt[['Municipio_encoded', 'Renda_per_capita', 'Expectativa_anos_estudo']]

# Variável alvo (o que queremos prever)
y = abt['Categoria_IDH']

# 70% dos dados para treino, 30% para teste
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# Criando o modelo
modelo = DecisionTreeClassifier()

# Treinando o modelo com os dados de treino
modelo.fit(X_train, y_train)

# Fazendo previsões com os dados de teste
y_pred = modelo.predict(X_test)

# Avaliando a acurácia do modelo
acuracia = accuracy_score(y_test, y_pred)
print(f'Acurácia do modelo: {acuracia}')

"""##Modelo de classificação utilizando o Pycaret"""

df1['Nivel_IDHM'] = pd.cut(df1['IDHM'], bins=[0, 0.55, 0.7, 0.8, 1],
                           labels=['Baixo', 'Médio', 'Alto', 'Muito Alto'])

# Configurar o ambiente PyCaret
clf1 = setup(data = df1,
             target = 'Nivel_IDHM',
             ignore_features = ['Estado'],  # Ignorar colunas não relevantes
             session_id=123)

# Comparar modelos
best_model = compare_models()
if best_model:
# Criar o modelo
  model = create_model(best_model)

# Ajustar o modelo
  tuned_model = tune_model(model)

# Avaliar o modelo
  predictions = predict_model(tuned_model)

# Finalizar o modelo
  final_model = finalize_model(tuned_model)

# Salvar o modelo
  save_model(final_model,'modelo_classificacao_IDHM')
else:
    print("Nenhum modelo adequado encontrado.")

"""##Modelo de Rede Neural"""

le = LabelEncoder()
df1_numeric['Município'] = le.fit_transform(df['Município'])
#Selecionando features e target
X = df1_numeric.drop('IDHM', axis=1)  # Features
y = df1_numeric['IDHM']               # Target
#Divisão de modelo treino e teste
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
#Normalizando os dados
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)
#Construindo modelo
model = Sequential()
model.add(Dense(64, activation='relu', input_shape=(X_train.shape[1],)))
model.add(Dense(32, activation='relu'))
#Calculando o numero de classes 'Nivel_IDHM'
num_classes = df1['Nivel_IDHM'].nunique()
model.add(Dense(num_classes, activation='softmax'))

#Compilando modelo
model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

print("X_train shape:", X_train.shape)
print("y_train shape:", y_train.shape)
print("X_test shape:", X_test.shape)
print("y_test shape:", y_test.shape)


y_train = y_train.to_numpy()
y_test = y_test.to_numpy()

from tensorflow.keras.utils import to_categorical
y_train = to_categorical(y_train, num_classes=num_classes)
y_test = to_categorical(y_test, num_classes=num_classes)

#Treinando o modelo
model.fit(X_train, y_train, epochs=50, batch_size=32, validation_data=(X_test, y_test))

loss, accuracy = model.evaluate(X_test, y_test)
print(f'Loss: {loss}, Accuracy: {accuracy}')